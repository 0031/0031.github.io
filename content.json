[{"title":"SpringMVC绑定Json参数之忽略未知属性","date":"2017-03-09T02:48:13.000Z","path":"2017/03/09/spring-mvc-json-ignore-properties/","text":"莫名其妙，今天往后台发送请求时，报400错误，控制台也不打印异常，不进入控制器。原来由于使用SpringMVC进行参数绑定的时候，对传入的参数有一定的限制，不符合要求就会响应400错误。发生该错误有2个原因： 参数名相同，参数类型不一致。 传入了未知属性，对复杂数据类型来说，例如如User中只有name属性，请求内容中却有name和age。 参数绑定SpringMVC为了方便开发者，特地提供了一些基本参数绑定方式，如简单类型的参数绑定、Pojo参数绑定、List参数绑定、Map参数绑定等等。这里不描述其方法，如有需要请移步SpringMVC中的参数绑定总结，当然，网上也有很多相关教程。 Json参数绑定敲黑板，Json格式的参数绑定非常实用！！！上面的参数绑定基本是围绕表单数据，并不是所有的场景都适用，当除了需要传表单数据还有附加其他复杂的数据，则需要封装成Json格式发到后台。 配置Json参数绑定： 前台发送请求 12345678910111213141516171819202122var user = &#123; name: '张三', sex: '男', age: 20, place: '北京东城区'&#125;;$.ajax(function()&#123; url: '/checkUser', // 向后台发送数据的参数格式 dataType: 'json', // 接收后台响应数据的格式 contentType: 'application/json;charset=utf-8', data: JSON.stringify(&#123; user: user &#125;)&#125;).then(function(data)&#123; // success&#125;).fail(function(error)&#123; // fail&#125;); 后台接收请求 控制器： 12345678910@RequestMapping(value = \"checkUser\")// 加入@ResponseBody注解，SpringMVC使用Jackson将返回值转为Json格式public @ResponseBody String checkUser(User user) &#123; // get some data... User u = new User(\"张三\",\"男\",20); if(user == u)&#123; return \"同一个人\"; &#125; return \"不是同一个人\";&#125; User：123456789public class User &#123; private String name; private String sex; private int age; User(String name,String sex,int age)&#123; // ... &#125; // getter... setter...&#125; 逻辑上来说，上述代码没有什么问题，可是SpringMVC会抛出400异常，开篇已经解释了原因，这里的place作为未知属性传入，是Spring无法进行参数绑定的，参数名为user所对应的属性一致，可以少但不可以多。 为了解决这样的错误，有两种方案： 1.不传place字段2.修改后台配置，使其能够过滤未知属性 可想而知，选后者更明智一些。 过滤未知属性只需要在User前增加一个注解@JsonIgnoreProperties(ignoreUnknown=true) User：123456// 忽略传入的json未知属性@JsonIgnoreProperties(ignoreUnknown=true)public class User &#123; // attrs... // getter... setter...&#125; 再试试看，这次不会再有错了吧。 最后每一次的记录，只是为了下一次少踩坑，减少错误的发生，写更稳定的代码！","tags":[{"name":"SpringMVC","slug":"SpringMVC","permalink":"/tags/SpringMVC/"},{"name":"参数绑定","slug":"参数绑定","permalink":"/tags/参数绑定/"}]},{"title":"或许bootstrap-table能提高你的开发效率","date":"2017-03-07T01:56:46.000Z","path":"2017/03/07/perhaps-the-bootstrap-table-is-a-good-choice/","text":"开发中经常遇到后台数据展示至前台的场景，其中用表格批量展示数据的情况尤其多。那么如何能快速的将复杂的数据格式清晰的显示在网页中，这是一个问题。或许你会想到，拿到后台数据，然后通过拼接参数，渲染完成一张表格，然后手动插入到dom中。不过，听起来貌似涉及到的步骤不少，至少在我看来，这样的方式效率不会很高（当然如果使用模板引擎辅助渲染，应该还是不错的）。当然，你也会考虑到使用插件，不过表格插件有不少，做得好的也有很多，bootstrap-table就是其中之一。由于官方文档示例比较丰富，但是在某些配置上没有做足够的说明，所以我记录了一点点遇到的小坑。 渊源最近比较喜欢找点开源插件投入到项目中去，不再像以前那样闭门造轮子。上手所在单位的项目，发现之前的开发者像上面说的那种通过JS自定义拼接的原始方式来完成数据展示。当然，本来我也可以直接复制下之前的代码，然后改一改就完成了，不过作为强迫症轻微患者，并不喜欢这样的做法。想到了之前项目中有学习过bootstrap-table，由于当时没有太多深入，就丢弃了。这个项目非常适合使用它，于是在Github中找到了它。 开始使用刚好，示例网站的首页正是我需要的，项目需求是可删除可编辑，那么好，开始吧。开始前，你需要引入相关样式和脚本，推荐Bootcdn或者Rawgit。 12345&lt;link rel=\"stylesheet\" href=\"https://cdn.bootcss.com/bootstrap/3.3.7/css/bootstrap.min.css\"&gt;&lt;link rel=\"stylesheet\" href=\"https://cdn.bootcss.com/bootstrap-table/1.11.1/bootstrap-table.css\"&gt;&lt;script src=\"https://cdn.bootcss.com/jquery/3.1.1/jquery.min.js\"&gt;&lt;/script&gt;&lt;script src=\"https://cdn.bootcss.com/bootstrap/3.3.7/js/bootstrap.min.js\"&gt;&lt;/script&gt;&lt;script src=\"https://cdn.bootcss.com/bootstrap-table/1.11.1/bootstrap-table.min.js\"&gt;&lt;/script&gt; 由于详细代码篇幅比较大，不在文章中贴出，如果实在想要，请看小提示：-) 普通表格： 带删除按钮： 带编辑功能： Tips:右键表格查看框架源代码，即可查看如何生成表格。 请注意：增加编辑功能，需要额外添加如下样式和脚本（之前我忘记了加bootstrap-table/1.11.1/extensions，踩了一个大坑，另外bootstrap与bootstrap-editable版本需要一一对应）： 123&lt;link rel=\"stylesheet\" href=\"https://cdn.bootcss.com/x-editable/1.5.1/bootstrap3-editable/css/bootstrap-editable.css\"&gt;&lt;script src=\"https://cdn.bootcss.com/bootstrap-table/1.11.1/extensions/editable/bootstrap-table-editable.js\"&gt;&lt;/script&gt;&lt;script src=\"https://cdn.bootcss.com/x-editable/1.5.1/bootstrap3-editable/js/bootstrap-editable.min.js\"&gt;&lt;/script&gt; 更多由于官方文档更丰富，只是我个人觉得好用，分享出来，就不在此一一举栗了，可以移步官网bootstrap-table-examples查看更多，或许你能发现更多有趣的东西！","tags":[{"name":"Table","slug":"Table","permalink":"/tags/Table/"},{"name":"Plugin","slug":"Plugin","permalink":"/tags/Plugin/"}]},{"title":"Hibernate校验器的正确打开方式","date":"2017-02-22T01:16:08.000Z","path":"2017/02/22/hibernate-validation/","text":"之前学习SpringMVC时，听说过一些校验器，在Bean中配置一些注解，即可方便的进行参数验证。但是由于当时在学校，写的系统并不太复杂，参数并不多，还有就是没有花心思去学（说白了就是懒），因此没有用到。但现在来实习，发现他们以前写的代码和我在学校写的类似，但是参数太多，意味着加一个参数就要在控制器中新加一行代码，非常不便于维护。所以我才选择了校验器来对他们的代码进行优化（算是为自己减少维护量吧，实在是涉及的字段有点多），于是找到了Hibernate校验器。 注解关于引用依赖包可以查看[参考来源]，下面说说常用注解： 注解 作用 AssertTrue 布尔值为真 AssertFalse 布尔值为假 Null 引用为空 NotNull 引用不为空 NotEmpty 字符串引用和值都不是空 Min 数字的最小值 Max 数字的最大值 Past 日期必须是过去 Future 日期必须是未来 Pattern 字符串必须匹配正则表达式 Valid 递归验证引用 Size 验证字符串是否在Size范围内 Email 验证字符串是否是一个有效的电子邮箱 URL 字符串是否是一个有效的URL 如何使用在bean中需要做验证的变量前加入注解，示例如下： 12345678910111213public class User &#123; // 用户名肯定不允许为空吧 @NotEmpty private String name; // 加入时间肯定不能是将来时吧，也不能为空吧 @Past @NotNull private Date joinDate; // 年龄不能为负数吧，最久也没听说过活到150的吧（大不了顶破天给他个200） @Size(min = 0, max = 150) private int age; // get/set方法不在此贴出&#125; 然后在控制器中执行验证即可： 123456789101112131415161718@Controllerpublic class LoginController &#123; @RequestMapping(value = \"login\", method = RequestMethod.POST) public int getArchiveTable(User user) &#123; // 先初始化校验器 ValidatorFactory factory = Validation.buildDefaultValidatorFactory(); Validator validator = factory.getValidator(); Set&lt;ConstraintViolation&lt;T&gt;&gt; set = validator.validate(user); // 如果集合元素个数为0，通过验证 if(set.size() == 0)&#123; // 此处执行其他逻辑... // 返回至页面 return 1; &#125; // 未通过验证 return 0; &#125;&#125; 自定义工具类由于经常使用到几个变量，为提高复用性，节省开发时间，因此诞生了一个Util工具类： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950// Hibernate校验器帮助类，对一些内部变量做了统一处理// 在bean中需要配置校验注解例如@NotNull、@Valid等public class ValidateUtil &#123; // 使用校验器，先对数据进行合法性校验 private static ValidatorFactory factory; private static Validator validator; static&#123; factory = Validation.buildDefaultValidatorFactory(); validator = factory.getValidator(); &#125; // 使用完后销毁factory对象 public void finalize() &#123; factory.close(); &#125; // 执行校验并返回校验结果集 public static &lt;T&gt; Set&lt;ConstraintViolation&lt;T&gt;&gt; validate(T obj)&#123; return validator.validate(obj); &#125; // 执行校验并返回是否合法，合法返回true public static &lt;T&gt; boolean isLegal(T obj)&#123; return validate(obj).size() == 0 ? true : false; &#125; // 获取出错的字段集合 public static &lt;T&gt; List&lt;String&gt; getErrorProperties(Set&lt;ConstraintViolation&lt;T&gt;&gt; set)&#123; return getErrors(set, false); &#125; // 获取出错信息集合 public static &lt;T&gt; List&lt;String&gt; getErrorMessages(Set&lt;ConstraintViolation&lt;T&gt;&gt; set)&#123; return getErrors(set, true); &#125; /** * 获取出错信息 * @param showMsg 是否显示详细信息 * @return */ public static &lt;T&gt; List&lt;String&gt; getErrors(Set&lt;ConstraintViolation&lt;T&gt;&gt; set, boolean showMsg)&#123; List&lt;String&gt; list = new ArrayList&lt;String&gt;(); if(set.size() != 0)&#123; for (ConstraintViolation&lt;T&gt; c : set) &#123; String error = c.getPropertyPath().toString(); // 如果需要显示出错详细信息 if(showMsg)&#123; error += c.getMessage().toString(); &#125; list.add(error); &#125; &#125; return list; &#125;&#125; 如果您觉得我的方法有需要优化的地方，欢迎在评论区吐槽！O(∩_∩)O~ 如果使用工具类，那么在控制器中的代码可以简化了： 1234567891011121314@Controllerpublic class LoginController &#123; @RequestMapping(value = \"login\", method = RequestMethod.POST) public int getArchiveTable(User user) &#123; // 通过工具类判断参数是否合法 if(ValidateUtil.isLegal(user))&#123; // 此处执行其他逻辑... // 返回至页面 return 1; &#125; // 未通过验证 return 0; &#125;&#125; 最后废话几句为了节省维护成本，前期多花时间写高质量的代码，否则慢慢的会发现，越来越多的坑在前面等着你。 参考来源： ① Hibernate Validator简介","tags":[{"name":"Hibernate","slug":"Hibernate","permalink":"/tags/Hibernate/"},{"name":"参数验证","slug":"参数验证","permalink":"/tags/参数验证/"}]},{"title":"Java中的diamond运算符  --  JDK 1.7新特性","date":"2017-02-14T02:54:06.000Z","path":"2017/02/14/diamond-operator/","text":"拷贝前辈之前做过的项目到本机，启动运行控制台打出如下错误： 12[ERROR] -source 1.6 中不支持 diamond 运算符[ERROR](请使用 -source 7 或更高版本以启用 diamond 运算符) 项目中出现很多小红叉，但是打开报错的文件，却没有发现错误，至少来说，提示错误的地方并没有逻辑错误。那好，咱就把Eclipse关于Html、Js、Xml的验证给关闭，刷新缓存，好了，没有小红叉，但是运行仍然打印出上面的结果。 查阅资料后才了解到JDK 1.7的一个新特性 —— diamond运算符。 新特性介绍增强对通用实例创建（diamond）的类型推断 ：类型推断是一个特殊的烦恼，下面的代码： 1Map&lt;String, List&lt;String&gt;&gt; map = new HashMap&lt;String, List&lt;String&gt;&gt;(); 通过类型推断后变成： 1Map&lt;String, List&lt;String&gt;&gt; map = new HashMap&lt;&gt;(); 这个&lt;&gt;被叫做diamond（钻石）运算符，这个运算符从引用的声明中推断类型。 修改Maven配置解决上述运行问题，需要修改maven编译版本。找到pom.xml中的maven-compiler-plugin位置： 12345678&lt;plugin&gt; &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt; &lt;configuration&gt; &lt;debug&gt;true&lt;/debug&gt; &lt;source&gt;1.6&lt;/source&gt; &lt;target&gt;1.6&lt;/target&gt; &lt;/configuration&gt;&lt;/plugin&gt; 修改为1.7以上即可（我的JDK本地环境为1.8）： 12345678&lt;plugin&gt; &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt; &lt;configuration&gt; &lt;debug&gt;true&lt;/debug&gt; &lt;source&gt;1.8&lt;/source&gt; &lt;target&gt;1.8&lt;/target&gt; &lt;/configuration&gt;&lt;/plugin&gt; 然后重新运行项目就不会出现不支持 diamond 运算符的问题了。 参考来源： ① 错误: -source 1.6 中不支持 diamond 运算符 (请使用 -source 7 或更高版本以启用 diamond 运算符)② mvn 请使用 -source 7 或更高版本以启用 diamond 运算符","tags":[{"name":"Java","slug":"Java","permalink":"/tags/Java/"},{"name":"Maven","slug":"Maven","permalink":"/tags/Maven/"}]},{"title":"我的git常用命令","date":"2017-02-08T01:34:04.000Z","path":"2017/02/08/my-git-common-commands/","text":"开年上班第二天，用Git上传了一次不好的提交，想把错误提交记录删除，重新传过。之前也遇到过类似的事情，去网上找了一些方法，最终解决了，并且把解决办法也加入到了书签。但是，当我再次打开书签时，发现根据步骤做，貌似并没有解决，还差点把整个库删了。没错，一定是保存了假书签！o(╯□╰)o 尽管经过一番倒腾，解决了问题，但是还是有必要把一些我常用的命令记录下来，以后就不用到处再找。 初始化文件夹 自动创建.git文件夹 1git clone https://github.com/0031/return-to-top.git 手动创建，然后连接到远程仓库12git initgit remote add origin https://github.com/0031/return-to-top.git 提交修改① 加入需要提交的文件（“.”表示所有文件，可以用某个文件名替换表示单个文件） 1git add . ② 添加注释，方便查找 1git commit -m &quot;update something&quot; ③ 提交至远程仓库（“master可以替换为其他分支”） 1git push origin master 打标签① 显示当前所有标签 1git tag ② 含附注的标签 1git tag -a v1.0.4 -m &quot;This is version 1.0.4&quot; ③ 轻量级标签 1git tag v1.0.4 ④ 提交标签 单个： 1git push origin v1.0.4 所有： 1git push origin --tags ⑤ 标签删除 本地： 1git tag -d v1.0.4 远程： 1git push origin :refs/tags/v1.0.4 回滚当提交了一个不太好的记录时，有强迫症的我又容不得留下这样的历史，那么回滚扮演了一个重要的角色。网上有不少方式，其中有一种暴力的（备份删库移入备份），这样做貌似很简单，但是可能会出现无法挽救的局面。 总结了一下，还是应该这样做，比较安全一点： ① 查看日志，选择需要回滚到的commit id 1git log ② 选择某个id（前5位字符即可），重置 保留修改（建议使用）： 1git reset a1b2c 完全丢弃修改（可以先备份文件）： 1git reset --hard a1b2c ③ 提交回滚 1git push -f origin master 接下来可以提交新的修改了，和上面的步骤一致。 参考来源： ① Git打标签② git如何回滚远程仓库","tags":[{"name":"Git","slug":"Git","permalink":"/tags/Git/"}]},{"title":"一款简易的网页返回顶部JS原生插件","date":"2017-01-03T08:10:22.000Z","path":"2017/01/03/return-to-top-js-plugin/","text":"还是在使用Hexo博客时发现的小问题。一般来说，网站都会加入返回顶部按钮，但是在使用Yilia主题时，并没有发现，作为一个完美主义者，当然必须解决它。 为了不重复造轮子，将以前项目中的代码Copy过来，加入到Yilia源码中，发现之前的代码依赖jQuery，但Hexo中并没有jQuery，这就不可爱了赛。本来可以自行加上，但是如果仅仅为了一个按钮，多加入了几十K的脚本，肯定是不划算的啦。 于是，修修补补总算是做成了JS原生插件。并且通过bower打包发布到git，方便下次使用。那么本文就来说说修补细节以及它的“打开方式”。 功能分析&emsp;&emsp;由于之前的代码中并没有加入动画，由于背景图片是一个小火箭（图片来源于网络），如果加入动画可能更生动一些，只是需要多加载样式，这里我选择了animate.css做为动画样式表，通过JS控制class来改变不同状态下图片动画。当然，也有不需要动画的用户，因此须定制动画开关；同理，不需要背景图的用户，定制背景开关；另外，平滑滚动至顶部，提升用户体验，毋庸置疑；防止多次点击，只执行最后一次点击事件。 JS原生插件如何写&emsp;&emsp;经常使用jQuery，导致JS一些语法忘记。需要再次拾起请看：原生JavaScript插件编写指南。 复用&emsp;&emsp;本来这就是一个常用的功能，因此需要考虑复用和下次使用方便。怎么样更好用？这是一个值得考虑的问题，主要体现在打包工具上。参考了很多打包工具或者说包管理软件，如Webpack、Vue、Rollup、Fis。当然，对于仅仅一个JS插件来说，使用Bower+Gulp就够了，这算是两个比较老的工具了把，想学习的请看下面这几篇文章：&emsp;&emsp;Bower —— 管理你的客户端依赖关系&emsp;&emsp;Gulp入门指南&emsp;&emsp;前端自动化Gulp工具常用插件 &emsp;&emsp;通过一番整理，将该插件发布到git，传送门：return-to-top。往后看，将会告诉您该插件的使用方式。 开始使用Clone 如果没有NodeJS环境，直接clone（不建议此方式，不便于统一管理）： 1git clone https://github.com/0031/return-to-top.git NodeJS 首先确保工作环境下安装了NodeJS，由于Bower与Gulp基于NodeJS。如果还未安装，请前往下载：NodeJS，可能有点慢，能翻墙最好。在控制台输入如下代码，已检验是否安装完整： 1234$ node -vv6.9.2$ npm -v3.10.9 Bower 全局安装Bower： 1$ npm install -g bower 小技巧：国内Npm仓库速度太慢，可考虑使用淘宝Npm： 1$ npm install -g cnpm --registry=https://registry.npm.taobao.org 然后将所有Npm命令替换为Cnpm来使用，大大提高速度，如： 1$ cnpm install -g bower 自定义Bower下载目录 新建.bowerrc文件： 1$ touch .bowerrc 将.bowerrc文件内容修改为自定义路径： 123&#123; \"directory\" : \"yourpath\"&#125; 小技巧：建议将所有的第三方插件都放在js/css/images同目录下plugins目录，方便统一管理。 Return To Top 通过Bower即可安装return-to-top插件： 1$ bower install return-to-top --save 或者 1$ bower install https://github.com/0031/return-to-top --save 在/yourpath/return-to-top目录下即为插件核心内容。 示例 在/return-to-top/example/example.html可以查看示例文件。细心的童鞋可以发现，本站右下方可发现小火箭，是该插件最好的示例。另外，/return-to-top/dist目录下的文件用于生产环境使用。 动画效果 动画效果使用的animate.css来源于Bootcdn，您也可以通过Bower下载到本地： 1$ bower install animate.css --save 引入脚本 在需要使用返回顶部插件的html文件中加入如下代码，即可使用：1234&lt;script src=\"/yourpath/return-to-top/dist/return-to-top.min.js\"&gt;&lt;/script&gt;&lt;script type=\"text/javascript\"&gt; window.returnToTop.init();&lt;/script&gt; 需要将/yourpath替换为您的本地路径。 高级进阶如果想对插件有更高的要求，可以自定义源码。进入/return-to-top目录，执行npm安装： 1$ npm install 修改/return-to-top/src/js/return-to-top.js过后可以执行相关命令，开发环境下： 1$ npm run dev 可在/return-to-top/example目录下测试效果。注：开发时，对JS语法做了检查，请注意编程规范。 生产环境下： 1$ npm run dist 可对js进行压缩，使用时引入return-to-top.min.js以节省空间。 最后说几句开发此插件是方便自己，同时发布在git希望给大家带来一定的方便，虽然背景图片来源于网络，动画效果来源于animate，但其他内容均为原创，开发不易，使用时还望注明出处，非常感谢大家的支持！ 如果还有什么地方不明白，您可以在评论区留言！","tags":[{"name":"Plugin","slug":"Plugin","permalink":"/tags/Plugin/"},{"name":"Javascript","slug":"Javascript","permalink":"/tags/Javascript/"}]},{"title":"Linux下如何修改时区","date":"2016-12-28T08:27:55.000Z","path":"2016/12/28/linux-tzselect/","text":"上次有一篇文章写到了时区的修改，本应把这篇文章融在那里面，但是感觉好像代码又有点多，突出不了那篇文章的主题（是想突出Java中如何修改时区），因此把它移到这里来，做个小结。 键入 date -R ，查看时区：12[root@user ~]# date -RWed, 28 Dec 2016 08:48:12 +0000 可以看到这是0时区，才8点多，我所在的位置实际上已经16点多了。 键入 tzselect ，选择时区&emsp;这里我们选择Asia（亚洲）：123456789101112131415[root@user ~]# tzselectPlease identify a location so that time zone rules can be set correctly.Please select a continent or ocean. 1) Africa 2) Americas 3) Antarctica 4) Arctic Ocean 5) Asia 6) Atlantic Ocean 7) Australia 8) Europe 9) Indian Ocean10) Pacific Ocean11) none - I want to specify the time zone using the Posix TZ format.#? 5 &emsp;然后选择China（中国）：12345678910111213141516171819Please select a country. 1) Afghanistan 18) Israel 35) Palestine 2) Armenia 19) Japan 36) Philippines 3) Azerbaijan 20) Jordan 37) Qatar 4) Bahrain 21) Kazakhstan 38) Russia 5) Bangladesh 22) Korea (North) 39) Saudi Arabia 6) Bhutan 23) Korea (South) 40) Singapore 7) Brunei 24) Kuwait 41) Sri Lanka 8) Cambodia 25) Kyrgyzstan 42) Syria 9) China 26) Laos 43) Taiwan10) Cyprus 27) Lebanon 44) Tajikistan11) East Timor 28) Macau 45) Thailand12) Georgia 29) Malaysia 46) Turkmenistan13) Hong Kong 30) Mongolia 47) United Arab Emirates14) India 31) Myanmar (Burma) 48) Uzbekistan15) Indonesia 32) Nepal 49) Vietnam16) Iran 33) Oman 50) Yemen17) Iraq 34) Pakistan#? 9 &emsp;选择北京时间：1234Please select one of the following time zone regions.1) Beijing Time2) Xinjiang Time#? 1 &emsp;确认当期时间是否正确（这是掏出你的手表看下对不对O(∩_∩)~）：12345678910The following information has been given: China Beijing TimeTherefore TZ='Asia/Shanghai' will be used.Local time is now: Wed 28 Dec 17:08:05 CST 2016.Universal Time is now: Wed 28 Dec 09:08:05 UTC 2016.Is the above information OK?1) Yes2) No#? 1 &emsp;系统给了一个修改时区的命令：123456You can make this change permanent for yourself by appending the line TZ='Asia/Shanghai'; export TZto the file '.profile' in your home directory; then log out and log in again.Here is that TZ value again, this time on standard output so that youcan use the /usr/bin/tzselect command in shell scripts:Asia/Shanghai &emsp;复制其中的 TZ=’Asia/Shanghai’; export TZ ，并执行：1[root@user ~]# TZ='Asia/Shanghai'; export TZ &emsp;键入 键入 tzselect ，再次查看时间，则为东八区了：12[root@user ~]# date -RWed, 28 Dec 2016 17:10:16 +0800 当然，除了tzselect命令，还有其他一些修改时区的方法，就不在这里一一介绍了。","tags":[{"name":"Linux","slug":"Linux","permalink":"/tags/Linux/"},{"name":"Shell","slug":"Shell","permalink":"/tags/Shell/"},{"name":"OS","slug":"OS","permalink":"/tags/OS/"}]},{"title":"图片压缩以加快网站访问速度","date":"2016-12-25T14:09:18.000Z","path":"2016/12/25/image-compression/","text":"语文功底不好的我，绞尽脑汁写了几篇文章发布到服务器上，由于这其中包含了不少图片，测试访问速度并不理想，体验很差。虽然Hexo已经将网站转为静态页面了，性能提升很多，但毕竟用的github空间，不花钱，已经算是很不错的了。因此，只能先从图片上下功夫，至于js和css暂时不管。 网上找了很多优化方法，最终决定将图片资源托管至七牛CDN，不过据说后期图片多了会依赖它，然后慢慢你的钱包就分了一部分给它，我想七牛做得好才会由用户依赖吧（这里没有要给七牛做广告的意思），另外现在对我的博客来说还不到后期，将来的事情谁又知道呢~ 确定好方案，那就开整吧。 开通七牛CDN服务完成下列步骤即可： 注册七牛云账号 实名认证 新建对象存储 &emsp;&emsp;官网存储快速入门文档。 绑定加速域名 &emsp;&emsp;官网融合CDN加速快速入门文档。 完成上述步骤再通过下面的工具将本地文件上传即可使用。 自动同步插件首先根据网友推荐使用了一款插件：hexo-qiniu-sync。按照插件作者的描述，通过配置七牛的密钥，资源文件夹路径，然后在文章中插入特定标签，生成静态文件时，即可自动同步图片到七牛服务器。 看起来貌似很方便，而且也有不少人使用，到我手里就变了样。按照文档安装后并且配置七牛密钥后，运行这个插件时报错，导致不仅无法上传图片，而且本地预览文章都不行。 我也到讨论区看了，有同样的错误，但是作者没有在线，据说是忙于搬家大业。多次尝试无果，只好摒弃这个好用的插件（如果能用的朋友，请在评论区留言）。 手动同步工具来到七牛官网，找到了一个文件上传工具：qshell。经过一番倒腾，终于把图片文件夹弄到七牛服务器上了，详细操作步骤请看文档：qshell使用。只不过每次有文件变动，需要手动执行命令，有点不太方便。 以上方式治标不治本，虽然速度能够提升，但非常有限。 图片压缩围绕图片做优化，怎么能忘记它本身，如果有一张1000M的图片，就算使用CDN能提高多少速度，所以只有图片大小相对较小，才能更好的提升速度。 这里的相对较小，并不是能将1000M的图片变到1M，而是在同等宽高、画质差别不大的情况下进行图片压缩处理，使图片占用空间相较原图更小。 图片格式 &emsp;&emsp;读者可以了解下图片格式，并且选择某种格式来作为网站基准。当然，我推荐尽量使用JPEG(Joint Photographic Expert Group)，联合照片专家组，文件后缀名为“.jpg”或“.jpeg”，因为它是目前网络上最流行的图像格式，并且可以把文件压缩到最小，画质还不会收到太大的影响。 在线压缩工具 &emsp;&emsp;首先想到的就是利用在线压缩工具，我尝试把一张300K的jpg图片压缩，结果得到的图片只有20K，画质不会太差，这让我非常满意，于是继续压缩其他图片文件，最后整个3M的图片文件夹被我变成了400K左右，然后生成静态页面，发布到服务器。果然，访问速度得到大大改善。Tips：图片色彩差别最好不要太大，可以使用调色工具优化，否则压缩结果不会让你高兴。 图片压缩软件 &emsp;&emsp;如果图片太多，可以使用智图进行批量压缩，非常方便，安装完毕后，直接将图片文件夹拖入软件中，即时压缩，并且可以自定义压缩比例。 图片格式转码 &emsp;&emsp;直接修改后缀名？No,No,No！因为这样并没有真正修改格式，并且智图也不支持压缩这种类型的图片，那如何批量修改图片的后缀？推荐使用美图秀秀批处理（可能需要先安装美图秀秀），和智图一样直接拖放。在软件右侧选择更多-&gt;选择jpg格式-&gt;修改画质（建议60%-80%）： 当然，你还可以用它添加水印，做做美化什么的，更多功能需要自己去发现~ 最后压缩完图片后，结合CDN存储方式，整个网站访问起来就更快了，把js、css也一并放到CDN下也能提升速度，方法就不多说了。如果您有更好的优化方法，请在评论区留言！","tags":[{"name":"CDN","slug":"CDN","permalink":"/tags/CDN/"},{"name":"网站优化","slug":"网站优化","permalink":"/tags/网站优化/"},{"name":"图片压缩","slug":"图片压缩","permalink":"/tags/图片压缩/"}]},{"title":"时间在不同操作系统下不一致","date":"2016-12-25T02:53:17.000Z","path":"2016/12/25/time-not-consistent/","text":"时间不一致，是由于时区设置不统一，这个问题并不是所有开发者都能遇到，开发与生产环境都在同类型操作系统下，比如C#，均用Windows系统，就不用担心。 之前，我在博客上发布文章时，遇到了这个问题，发布文章时，本地时间15点多，而服务器上显示7点多，开始以为程序在时间戳上的转换可能有逻辑错误，通过打断点调试，并没有发现任何错误，然后又重新导出war包，放在服务器上，再次发布新的文章，可是问题依然没有得到解决。 于是只能求助于网络，了解了其中的原因。要解决该问题，首先需要了解几个东西： 格林威治标准时间（GMT）十七世纪，英国为了海上霸权的扩张计划，格林威治皇家天文台进行天体观测，1884年，决定通过格林威治的子午线作为划分地球东西两半球的经度零度。旧皇家观测所门口墙上有一个时钟，显示当下时间，这个时间就是世界时间参考点，这就是格林威治标准时间（Greenwich Mean Time）的由来。 世界协调时间（UTC）Coordinated Universal Time【为什么缩写是UTC，挠头(⊙o⊙)?】是经过平均太阳时（以GMT为准）、地轴运动修正后的新时标以及以秒为单位的国际原子时所综合精算而成的时间，计算过程相当严谨精密，因此UTC比GMT更加精准。 站在一个软件开发者角度来说，GMT =&gt; 时间标准1.0，UTC =&gt; 时间标准2.0，都可以用，只是对某些要求更高的人来说后者更适用。 东八区（GMT+8/UTC+8）在那个年代，中国海事比不上发达国家，因此只能沿用世界标准，由于地理位置因素，北京时间大约快了8个小时，因此东八区诞生了，本来全中国横跨多个时区，比如新疆时钟指向8点时，其实只有4点多，但为了全国标准一致，均使用北京时间，特别行政区除外。当然，我们在程序中看到的应该是 CST：中国标准时间（China Standard Time） 找到“病根”，对症“下药”！ 修改操作系统属性Linux： 由于代码篇幅比较大，请移步至Linux下如何修改时区。 Windows： 直接在桌面右下角找到时间的位置，然后选择日期和时间，弹出窗口中找到时区的更改即可，由于Windows不同版本界面不尽相同，所以不在此截图演示。 Mac： 穷屌买不起，无法做出任何说明。 修改程序代码（以Java示例）其实这才是本文重点，直接在程序代码中控制时区转换即可，一次付出，终身受益。方法也很简单，可以写一个关于时间的Util工具类：12345678910111213141516171819202122232425262728293031323334353637import java.text.SimpleDateFormat;import java.util.Calendar;import java.util.Date;import java.util.TimeZone;import org.apache.commons.logging.Log;import org.apache.commons.logging.LogFactory;public class TimeUtils &#123; // 日志，可以在调试过程中快速定位错误位置 protected static final Log log = LogFactory.getLog(TimeUtils.class); // 配置一个默认时区，当然也可以写入至xml文件中 public static final String TIME_ZOME = \"Asia/Shanghai\"; // 如果用到Calendar 可以这样修改时区 private static Calendar cal = Calendar.getInstance(); static &#123; cal.setTimeZone(TimeZone.getTimeZone(TIME_ZOME)); &#125; /** * 根据固定格式转换 * @param date 日期 * @param format 日期格式 如yyyy-MM-dd HH:mm:ss * @return */ public static String simpleDateFormat(Date date,String format)&#123; try &#123; SimpleDateFormat simpleDateFormat = new SimpleDateFormat(format); // 如果用SimpleDateFormat这样修改时区 simpleDateFormat.setTimeZone(TimeZone.getTimeZone(TIME_ZOME)); return simpleDateFormat.format(date); &#125; catch (Exception e) &#123; log.debug(\"日期格式化出错: \" + e.getMessage()); &#125; return null; &#125; /** 其他函数不在此贴出 **/&#125; 如此修改后，在今后的代码编写中不用在担心时区不统一的问题了。","tags":[{"name":"Java","slug":"Java","permalink":"/tags/Java/"},{"name":"OS","slug":"OS","permalink":"/tags/OS/"},{"name":"Timezone","slug":"Timezone","permalink":"/tags/Timezone/"}]},{"title":"乱码，这个让人头疼而又必须解决的问题","date":"2016-12-23T08:23:22.000Z","path":"2016/12/23/messy-code/","text":"在我最开始接触实际网站系统开发的时候，经常遇到文本乱码，并且始终没有解决完善，或许当时开发经验不够，没能做到面面俱到。这个问题确实非常让人头疼，如果不去完全解决它，将会影响后面的开发。 乱码类型&emsp;&emsp;常见的乱码，一般能够分成五种类型：第一类是文本/文档文档乱码，这一般是由于源文档编码，和Windows使用的编码不通用造成的；第二类是网页乱码，形成原因和第一类乱码类似；第三类是Windows系统界面乱码，即中文Windows的菜单、桌面、提示框等显示乱码，主要是Windows注册表中有关字体的部分配置不当引起的；第四类是应用程式的界面乱码，即各种应用程式（包括游戏）本来显示中文的地方出现乱码，形成原因比较复杂，有第二类的乱码原因，也可能是软件用到的中文链接库，被英文链接库覆盖造成的；第五类是邮件乱码，形成原因也极其复杂。 如何解决(以Java Web开发场景为基础) 开发工具：Eclipse 服务器：Tomcat 目标编码：UTF-8 统一Eclipse编码格式 修改Workspace编码格式&emsp;&emsp;在Eclipse菜单栏中，选择Windows-&gt;Perferences-&gt;General-&gt;Workspace，在右侧找到Text file encoding修改为UTF-8： 修改Workspace编码格式 图解 修改Project编码格式&emsp;&emsp;选择某个项目，单击右键，选择Properties-&gt;Resource，在右侧找到Text file encoding修改为UTF-8： 修改Project编码格式 图解 修改Content-Type&emsp;&emsp;在Eclipse菜单栏中，选择Windows-&gt;Perferences-&gt;General-&gt;Content-Type，在右侧找到Text-&gt;Java Source File(如果有使用到JSP文件可以找到Jsp)更新为UTF-8，切记一定要点击右边的Update： 修改Content-Type 图解 当然，为了所有文件都统一，可以全部更新，毕竟有些文件类型用不到 修改单个文件编码格式&emsp;&emsp;与Project类似，只是选择单个文件，这里就不截图了。 其实经过上述操作，基本上已经算编码统一了，写代码时不用担心出现乱码问题，但是，将项目发布至服务器上时，只要遇到POST请求，返回中文数据，依然出现乱码。那么此时就需要修改Tomcat配置文件中的编码才能解决这个问题。 修改Tomcat配置文件 调试时&emsp;&emsp;使用Eclipse有个好处，调试项目很容易，一键发布，因此解决乱码只需在Project Explorer找到Servers-&gt;server.xml（需要搭建好Tomcat环境），找到：1&lt;Connector port=\"8080\" protocol=\"HTTP/1.1\" connectionTimeout=\"20000\" redirectPort=\"8443\" /&gt; 修改为：1&lt;Connector port=\"8080\" protocol=\"HTTP/1.1\" connectionTimeout=\"20000\" redirectPort=\"8443\" URIEncoding=\"UTF-8\" /&gt; 项目正式发布时&emsp;&emsp;需要找到Tomcat安装目录下conf/server.xml，当然，修改位置不变。 最后&emsp;&emsp;上述步骤操作完成后，乱码问题将不会再出现，如果本文没有帮你解决问题或者文章有错误的地方，请在评论区留言。","tags":[{"name":"Java","slug":"Java","permalink":"/tags/Java/"},{"name":"Tomcat","slug":"Tomcat","permalink":"/tags/Tomcat/"},{"name":"Eclipse","slug":"Eclipse","permalink":"/tags/Eclipse/"}]},{"title":"遇见Hexo   ——   强大的静态博客框架","date":"2016-12-22T06:06:11.000Z","path":"2016/12/22/meet-hexo/","text":"之前写过一款Java博客，经验不足，没有及时做好数据库备份，导致服务器到期时，所有文章数据丢失。另外，由于是自己开发的博客，系统存在很多不足，因此经常混迹于各大技术论坛找材料修轮子。 一次偶然的机会，在GitHub上发现了Hexo，被它深深吸引。 如果在一两年前，或许我是不会用它的。每个程序猿都有一个独立创作的心，自己能做的，坚决不用别人的。当然，并不能完全否定这种开发方式，创新往往需要好的思路与独立实践。不过，对于初学者来说，开发能力尚有欠缺，往往做出来的东西，很多时候别人已经做过，并且做得比你好，那么那就是“重复造轮子”，也就成了初学者的一大痛点。 这里不再过多描述“重复造轮子”，来看下别人的“好轮子”：Hexo。 官网介绍 A fast, simple &amp; powerful blog framework. 快速、简洁且高效的博客框架。 确实如此，相比于“我造的轮子”好用多了。开发方式与开发语言也和我现在的开发方式不同，这对我来说是一次新的尝试。 使用感受几行代码即可轻松搭建好一个简易的博客，再修改下配置文件，做下个性化定制，属于自己的博客就生成了。至于搭建教程嘛，就不在这里说了，官方文档有说明，Google也可以看到很多。 框架内部自动进行渲染，生成文章静态页面，在本地即可预览效果。 文章使用MarkDown标记，非常易用，语法简单，个人感觉用起来非常爽，只不过和传统的博客使用在线编辑器来讲，可能体验稍差点，如果是没有开发基础的人员来用，比较吃力一些，加个后台管理页面会更好。 支持更换皮肤，这点也非常实用，可以自定义皮肤，Github上也有很多开源主题，当前博客就是使用的Yilia的主题，非常不错，不知屏幕前的您觉得如何呢？如果觉得不错就给大神一点支持吧(～￣▽￣)～ 代码托管至Github，再也不用担心服务器到期什么的弱爆了的问题。 最后废话几句希望那些正在“重复造轮子”的同学多逛逛技术论坛，发现一些好轮子，做做对比，才能知道自己的轮子存在哪些不足，然后做相应的修(创)补(新)，才能走得更远。 做的每一份努力，只为发现程序之美~","tags":[{"name":"Blog","slug":"Blog","permalink":"/tags/Blog/"},{"name":"发现","slug":"发现","permalink":"/tags/发现/"}]}]